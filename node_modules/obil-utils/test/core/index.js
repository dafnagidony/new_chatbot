process.env.DEBUG = 'myapp:*,myapp2:*';

var test = require('tape');
var core = require('../..').core;
var stdo;

test('Core', {skip: false}, function(t) {
  var hookStderr = function hookStderr(callback) {
    var oldWrite = process.stderr.write;

    process.stderr.write = (function(write) {
      return function(string, encoding, fd) {
        write.apply(process.stderr, arguments);
        callback(string, encoding, fd);
      };
    })(process.stderr.write);

    return function() {
      process.stderr.write = oldWrite;
    };
  };

  t.test('Interface', function(tt) {
    tt.test('should export a request implementation', function(ttt) {
      ttt.equal(typeof core.request, 'function', 'type of function');
      ttt.equal(typeof core.request.get, 'function', 'and expose get func.');
      ttt.equal(typeof core.request.post, 'function', 'and expose get func.');
      ttt.end();
    });

    tt.test('should export a debug implementation', function(ttt) {
      ttt.equal(typeof core.debug, 'function', 'type of function');
      ttt.end();
    });

    tt.end();
  });

  t.test('Instance of debug', function(tt) {
    var debug = core.debug('myapp');
    tt.equal(typeof debug.log, 'function', 'has log as func.');
    tt.equal(typeof debug.trace, 'function', 'has trace as func.');
    tt.equal(typeof debug.debug, 'function', 'has debug as func.');
    tt.equal(typeof debug.warn, 'function', 'has warn as func.');
    tt.equal(typeof debug.error, 'function', 'has error as func.');
    tt.end();
  });

  t.test('Debug sends', {skip: true}, function(tt) {
    var unHookStderr;
    var unHookStdTrace;
    var regTestError;
    var regTestTrace;
    tt.plan(1);
    stdo = core.debug('myapp2');
    regTestError = new RegExp('myapp2:error');
    regTestTrace = new RegExp('myapp2:trace');
    unHookStderr = hookStderr(function(string) {
      tt.ok(regTestError.test(string), 'looks like error');
    });
    stdo.error('foo');
    unHookStderr();
    unHookStdTrace = hookStderr(function(string) {
      tt.ok(regTestTrace.test(string), 'looks like trace');
    });
    stdo.trace('bar');
    unHookStdTrace();
  });

  t.end();
});

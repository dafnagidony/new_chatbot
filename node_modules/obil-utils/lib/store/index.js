var core = require('../core');
var debug = core.debug('obil.utils.store');
var createRedisStore;
var connectToStore;
var cleanCache;
var orm;

orm = exports.orm = require('./ormStore');
exports.session = require('./session');


/**
 * @method createRedisStore/connectToStore Factory for store
 * @param {Object} options Store options
 * @returns {<Object>} promise Promise fulfilled w/ store instance
 */
createRedisStore = function(options) {
  return require('./redisStore').manager.getStore(options);
};


/**
 * @method connectToStore Alias for createRedisStore - see above
 * @param {Object} options Store options
 * @returns {<Object>} promise Promise fulfilled w/ store instance
 */
exports.connectToStore = createRedisStore;


/**
 * @method cleanCache
 * @returns {undefined}
 */
cleanCache = exports.cleanCache = function() {
  return require('./redisStore').manager.cleanCache();
};


/**
 * @method connectionsProvider
 *
 * Sets store connections to different store type (using configuration)
 *
 * @param {Object} configurations Object with connection definition
 * @return {Array} connections Array with Promises of established connections
 */
exports.connectionsProvider = function(configurations) {
  var connections = [];

  function getAdapter(options) {
    var adapters;
    function redisAdapter() {
      return createRedisStore({
        store: {
          host: options.host,
          port: options.port,
          database: options.database
        }
      });
    }
    function ormAdapter() {
      return orm.connect(options);
    }
    adapters = {
      redis: redisAdapter,
      mysql: ormAdapter,
      postgres: ormAdapter,
      sqlite: ormAdapter,
      mongodb: ormAdapter,
      redshift: ormAdapter
    };
    if (typeof options.protocol !== 'string') {
      throw new TypeError('Protocol is required prop. in connection configuration');
    }

    if (!adapters[options.protocol]) {
      throw new Error(`Unsupported connection protocol ${options.protocol}`);
    }

    return adapters[options.protocol]();
  }

  Object.keys(configurations).forEach(function(key) {
    var options = configurations[key];
    var obj = {};
    const deprecatedKeysMap = {
      type: 'protocol',
      db: 'database'
    };

    // Temp.: warn with deprecated message, align connection conf. properties
    Object.keys(deprecatedKeysMap).forEach(function(deprecatedKey) {
      if (Object.keys(options).indexOf(deprecatedKey) > -1 && options[deprecatedKey]) {
        debug.warn(`${deprecatedKey} is deprecated as connection property, use ${deprecatedKeysMap[deprecatedKey]} instead`);
        options[deprecatedKeysMap[deprecatedKey]] = options[deprecatedKey];
        options[deprecatedKey] = undefined;
      }
    });

    obj[key] = getAdapter(options);
    connections.push(obj);
  });
  return connections.map(function(connection) {
    return connection[Object.keys(connection)[0]];
  });
};


/**
 * @method establishConnections
 *
 * Sets connections to all stores giving promises and configuration
 *
 * @param {Array} promisedConnections Promises of connections
 * @param {Object} configuration Connections configuration
 * @return {Object} Promise fulfilled with all established connections
 */
exports.establishConnections = function(promisedConnections, configuration) {
  var establishedConnections = [];
  return core.promise(function promiseToEstablishConnections(resolve, reject) {
    if (!promisedConnections.length) {
      return resolve(establishedConnections);
    }

    return core.promise.all(promisedConnections).then(function resolveEstablishConnections(results) {
      results.forEach(function(connection, idx) {
        var obj = {};
        obj[Object.keys(configuration)[idx]] = connection;
        establishedConnections.push(obj);
      });
      return resolve(establishedConnections);
    }).catch(function rejectEstablishConnections(err) {
      return reject(err);
    });
  });
};


/**
 * @method closeConnections
 *
 * Closes connections
 *
 * @param {Object} connections Connections
 * @return {Object} Promise fulfilled with closed stores
 */
exports.closeConnections = function(connections) {
  return core.promise(function promiseToShutdownConnections(resolve, reject) {
    var promisesToClose = [];
    if (!connections.length) {
      return resolve();
    }
    connections.forEach(function(connection) {
      var closing = function() {
        return core.promise(function promiseToClose(resolve2) {
          connection[Object.keys(connection)[0]].close(function() {
            return resolve2();
          });
        });
      };
      promisesToClose.push(closing());
    });

    return core.promise.all(promisesToClose).then(function() {
      cleanCache();
      return resolve(connections);
    }).catch(function(err) {
      return reject(err);
    });
  });
};

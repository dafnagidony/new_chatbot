var ENV = process.env;
var app = require('./app');
var errors = require('http-errors');
var http = require('http');
var path = require('path');
var pkg = require('../package');
var utils = require('obil-utils');
var debug = utils.core.debug('obil:server');
var promise = utils.core.promise;
var store = utils.store;
var consul = utils.config.consul;
var helpers = utils.helpers;


/**
 * Server
 * @class Server(options)
 * @param {Object} options
 * @param {Object} options.app App configuration (see ./app.js)
 * @param {Object} options.connections Connection (usually to stores) required for application
 * @param {String} options.host Server host
 * @param {Number} options.port Server port
 * @param {String} options.env Environment
 * @returns {Object} Instance of server
 */
function Server(options) {
  var opts = Object.assign({}, {
    hostname: ENV.NODE_HOST || 'localhost',
    port: ENV.NODE_PORT || 3000,
    env: ENV.NODE_ENV || 'development',
    name: '',
    path: '',
    connections: {},
    services: {}
  }, options);

  var _agent;
  var _application;
  var _appConfiguration;
  var _connections;
  var _options = opts;
  var _server;
  var _services;
  var _started = false;

  if (opts.host && !(/:\d*$/.test(opts.host))) {
    debug.warn('conf. property "host" is deprecated. Use "hostname" instead');
    options.hostname = options.host;
  }

  Object.defineProperties(this, {
    app: {
      get: function() {
        return _application;
      },
      set: function(state) {
        _application = state;
      },
      enumerable: true
    },
    appConfiguration: {
      get: function() {
        return _appConfiguration;
      },
      set: function(state) {
        _appConfiguration = state;
      },
      enumerable: true
    },
    agent: {
      get: function() {
        return _agent;
      },
      set: function(state) {
        _agent = state;
      },
      enumerable: true
    },
    connections: {
      get: function() {
        return _connections;
      },
      set: function(connections) {
        _connections = connections;
      },
      enumerable: true
    },
    options: {
      get: function() {
        return _options;
      },
      set: function(state) {
        _options = state;
      },
      enumerable: true
    },
    server: {
      get: function() {
        return _server;
      },
      set: function(state) {
        _server = state;
      },
      enumerable: true
    },
    services: {
      get: function() {
        return _services;
      },
      set: function(services) {
        _services = services;
      },
      enumerable: true
    },
    started: {
      get: function() {
        return _started;
      },
      set: function(state) {
        _started = state;
      }
    }
  });
}


/**
 * @function start
 */
Server.prototype.start = function start() {
  const self = this;

  function prepareConfiguration() {
    const PACKAGE_FILE_NAME = 'package.json';
    var config = self.options;
    var pckg;

    self.appConfiguration = config.app;

    if (self.appConfiguration) {
      debug.warn('configuration specified in "config.app" key is deprecated. All config. props. should reside in main config. object');
    } else {
      self.appConfiguration = {
        aclFree: config.aclFree,
        healthCheck: config.healthCheck,
        logger: config.logger,
        metrics: config.metrics,
        mountPoint: config.mountPoint,
        plugins: config.plugins,
        routes: config.routes,
        session: config.session
      };
    }

    return promise(function promiseToPrepareConfiguration(resolve) {
      utils.helpers.getFilePaths(__dirname, PACKAGE_FILE_NAME, function(dirs) {
        self.options.path = dirs[dirs.length - 1] || path.resolve(__dirname, '../');
        pckg = require(path.join(self.options.path, PACKAGE_FILE_NAME));
        self.appConfiguration.locals = {
          name: config.name || pckg.name,
          version: pckg.version,
          rootPath: self.options.path
        };
        return resolve(self);
      });
    });
  }

  function createApplication() {
    return promise(function promiseToCreateApplication(resolve, reject) {
      var opts = Object.assign({}, self.appConfiguration, {
        connections: self.connections,
        services: self.services
      });

      try {
        self.app = app(opts);
        self.server = http.createServer(self.app);
        return resolve(self);
      } catch (e) {
        return reject(e);
      }
    });
  }

  function connectToStores() {
    var connections = {};
    var connectionsConfiguration = self.options.connections;

    connections = store.connectionsProvider(connectionsConfiguration);

    return promise(function promiseToConnectToStores(resolve, reject) {
      store.establishConnections(connections, connectionsConfiguration).then(function(establishedConnections) {
        self.connections = establishedConnections;
        return resolve(self);
      }).catch(function(err) {
        return reject(new Error('Could not establish all connections to start server: ', err));
      });
    });
  }

  function registerAsService() {
    return promise(function promiseToRegisterAsService(resolve) {
      if (self.options.consul) {
        return consul.agent.register(self.options.name, self.options).then(function(agent) {
          self.agent = agent;
          return resolve(self);
        }).catch(function(err) {
          debug.warn('could not register in service discovery service, will continue without it', err);
          return resolve();
        });
      }
      return resolve(self);
    });
  }

  function discoverServices() {
    var servicesConfiguration = self.options.services;
    var discoverableServices;

    var findDiscoverableServices  = function findDiscoverableServices() {
      self.services = servicesConfiguration;
      return Object.keys(servicesConfiguration).filter(function(key) {
        return servicesConfiguration[key].discoverable;
      });
    };

    discoverableServices = findDiscoverableServices();

    return promise(function promiseToDiscoverServices(resolve) {
      consul.client.discoverServices(discoverableServices, servicesConfiguration).then(function(services) {
        self.services = services;
        return resolve(self);
      });
    });
  }

  function startServer() {
    return promise(function promiseToStartServer(resolve) {
      self.server.listen(self.options.port, self.options.hostname, function onStart() {
        self.started = true;
        debug.info('listening at http://%s:%s', self.server.address().address, self.server.address().port);
        return resolve(self);
      });
    });
  }

  function registerRoutes() {
    return promise(function promiseToRegisterRoutes(resolve) {
      self.app.once('routesConnected', function() {
        debug.info('routes connected');
        return resolve(self);
      });
    });
  }

  return promise(function startAction(resolve, reject) {
    if (self.started) {
      return reject(new Error('The server is already running'));
    }

    return promise.all([
      prepareConfiguration(),
      connectToStores(),
      registerAsService(),
      discoverServices()
    ]).then(function() {
      createApplication().then(function() {
        promise.all([
          startServer(),
          registerRoutes()
        ]).then(function() {
          var log = helpers.map().get('logger');
          var runEnv = (self.options.env || '').toUpperCase();
          debug.info('server up and ready in ' + runEnv + ' environment');
          // logging  supported conditionally
          if (log) {
            log.notice('Server started in ' + runEnv + ' environment');
          }
          return resolve(self);
        }).catch(function(err) {
          return reject(err);
        });
        self.app.emit('start');
      }).catch(function(err) {
        return reject(err);
      });
    });
  });
};


/**
 * @function stop
 */
Server.prototype.stop = function stop() {
  const self = this;

  function stopServer() {
    return promise(function promiseToStopServer(resolve) {
      var host = self.server.address().address;
      var port = self.server.address().port;
      var log = helpers.map().get('logger');
      self.server.close(function onStop() {
        self.started = false;
        debug.info('stopped listening at http://%s:%s', host, port);
        // logging  supported conditionally
        if (log) {
          log.warn('Server shut down');
        }
        return resolve(self);
      });
    });
  }

  function deregisterAsService() {
    return promise(function promiseToDeregisterAsService(resolve) {
      if (self.agent) {
        return self.agent.deregister().then(function() {
          return resolve(self);
        }).catch(function(err) {
          debug.warn('problem with deregistering service', err);
          return resolve(self);
        });
      }
      return resolve(self);
    });
  }

  return promise(function promiseToStop(resolve) {
    if (!self.started) {
      return resolve(self);
    }

    if (self.app.get('metricsClient')) {
      self.app.get('metricsClient').close();
    }

    if (self.app.get('logstashClient')) {
      self.app.get('logstashClient').close();
    }

    return promise.all([
      store.closeConnections(self.connections),
      deregisterAsService()
    ]).then(function() {
      stopServer().then(function() {
        debug.info('server closed');
        return resolve(self);
      });
    });
  });
};


/**
 * @function restart
 */
Server.prototype.restart = function restart(options) {
  const _options = options || {};
  const self = this;

  return self.stop().then(function onRestart() {
    return self.start(_options);
  });
};


/**
 * @function start
 * Exposing start method on module
 */
Server.start = function(options) {
  const _options = options || {};
  return (new Server(_options)).start();
};

Server.version = Server.prototype.version = pkg.version;
Server.utils = utils;
Server.errors = errors;

module.exports = Server;

var fs = require('fs');
var url = require('url');
var path = require('path');
var pkg = require('../../package');
var replaceStream = require('replacestream');
var utils = require('obil-utils');
var promise = utils.core.promise;
var settle = utils.core.settle;
var request = utils.core.request;
var helpPage = path.join(path.resolve(__dirname), '../static/help.html');


/**
 * info Returns few basic information about service
 * @param {Object} req Request
 * @param {Object} res Response
 * @returns {undefined}
 */
exports.info = (req, res) => {
  res.send({
    message: 'info',
    service: req.app.locals.name,
    version: req.app.locals.version,
    server: 'obil-server_' + pkg.version,
    nodejs: process.version
  });
};

/**
 * help Handles help HTML page
 * @param {Object} req Request
 * @param {Object} res Response
 * @returns {undefined}
 */
exports.help = (req, res) => {
  fs.createReadStream(helpPage)
    .pipe(replaceStream('%SERVICE_NAME%', (req.app.locals.name || pkg.name)))
    .pipe(res);
};

/**
 * revision Output revision number
 *
 * @desc Method uses path (shaPath) that ultimately resolves to path (rootPath) of parent
 * (consuming) project. With fallback to current directory.
 *
 * @param {Object} req Request
 * @param {Object} res Response
 * @returns {undefined}
 */
exports.revision = (req, res) => {
  var shaPath = path.join((res.app.locals.rootPath || path.resolve('.')), '.gitsha');
  fs.stat(shaPath, (err) => {
    if (err) {
      return res.send('unavailable');
    }
    return fs.createReadStream(shaPath).pipe(res);
  });
};

/**
 * selftest Handles connections and services check, and merges
 * result of healthCheck function
 *
 * TODO: refactor this into smaller functions and improve test coverage.
 * Perhaps new functions can be moved to utilities.
 * As of now this function complexity factor is 7.
 *
 * @param {Object} options
 * @returns {undefined}
 */
exports.selftest = function(options) {
  const HEALTH_ROUTE = 'ping';
  const HEALTH_RESPONSE = 'pong';
  var opts = options || {};

  var getRequestUri = (name) => {
    return url.format(opts.services[name]);
  };
  var createServiceRequest = (uri) => {
    return request({
      uri: [uri, HEALTH_ROUTE].join('/'),
      json: true
    });
  };
  var promiseConnections = () => {
    var connections = {};
    return promise((resolve) => {
      opts.connections.forEach((name) => {
        Object.keys(name).forEach((conn) => {
          var connection = {
            host: name[conn].client.address,
            alive: name[conn].active
          };
          connections[conn] = connection;
        });
      });
      return resolve({
        connections: connections
      });
    });
  };
  var promiseServices = () => {
    var promisedRequests = [];
    var services = {};
    var servicesStack = [];
    return promise((resolve) => {
      promisedRequests = Object.keys(opts.services).map((name) => {
        var service = {
          name: name,
          info: {
            host: getRequestUri(name),
            alive: false
          }
        };
        servicesStack.push(service);
        return createServiceRequest(service.info.host);
      });
      settle(promisedRequests).then((results) => {
        results.forEach((result, idx) => {
          var service = servicesStack[idx];
          service.info.alive = (result.value === HEALTH_RESPONSE);
          services[service.name] = service.info;
        });
        return resolve({
          services: services
        });
      });
    });
  };
  var promiseHelthCheck = function() {
    return promise((resolve) => {
      var check = opts.healthCheck();
      if (typeof check !== 'object') {
        return resolve();
      }
      return resolve(check);
    });
  };

  return function(req, res) {
    var promisedTests = [];
    var selfCheck = {};

    if (opts.connections.length) {
      promisedTests.push(promiseConnections());
    }
    if (Object.keys(opts.services).length) {
      promisedTests.push(promiseServices());
    }
    if (typeof opts.healthCheck === 'function') {
      promisedTests.push(promiseHelthCheck());
    }

    promise.all(promisedTests).then((results) => {
      results.forEach((result) => {
        Object.keys(result).forEach((key) => {
          if (!selfCheck[key]) {
            selfCheck[key] = result[key];
            return;
          }
          Object.assign(selfCheck[key], result[key]);
          return;
        });
      });
      return res.send(selfCheck);
    });
  };
};

/**
 * version Provides name, version & dependency about service
 * @param {Object} req Request
 * @param {Object} res Response
 * @returns {undefined}
 */
exports.version = (req, res) => {
  res.send({
    name: req.app.locals.name,
    version: req.app.locals.version,
    dependencies: req.app.locals.dependencies
  });
};


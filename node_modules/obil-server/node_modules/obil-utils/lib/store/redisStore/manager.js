var _ = require('lodash');
var redisStore = require('./redis');
var core = require('../../core');
var configCache = {};


/**
 * @function getStore Helps managing multiple stores initialization
 * @desc Ensures single instance of store is provided based on socket, host & port options.
 * If such combination already refers a store it will return it instead of creating new one.
 * @property {<Object>} options Store options
 * @returns {<Object>} promise Promise fulfilled with store instance
 */
exports.getStore = function getStore(options) {
  var opts = _.defaultsDeep(options || {});
  var storeOptions = [];
  var configIndex = 0;
  var instance = null;

  ['socket', 'host', 'port', 'database'].forEach(function(key) {
    if (opts.store && opts.store[key]) {
      storeOptions.push(opts.store[key]);
    }
  });

  function isCached(optValues) {
    var exists = true;
    if (!optValues) {
      return false;
    }
    storeOptions.forEach(function(opt) {
      if (optValues.indexOf(opt) < 0) {
        exists = false;
      }
    });
    return exists;
  }

  function isConnectionActive(inst) {
    if (inst.active) {
      clearInterval(inst.connectionCheck);
      return true;
    }
    return false;
  }

  return core.promise(function promiseGetStore(resolve, reject) {
    Object.keys(configCache).forEach(function storeCacheCheck(storeKey) {
      var retryCount = 0;
      var CHECK_CONNECTION_REPEAT = 100;
      configIndex += 1;
      if (isCached(configCache[storeKey].options)) {
        instance = configCache[storeKey].store;
        if (!instance.active) {
          instance.connectionCheck = setInterval(function() {
            retryCount += 1;
            if (isConnectionActive(instance)) {
              return resolve(instance);
            }
            if (retryCount > 300) {
              return reject(new Error('gave up connection retry after 30 sec'));
            }
            return instance;
          }, CHECK_CONNECTION_REPEAT);
        } else {
          return resolve(instance);
        }
      }
      return false;
    });
    if (!instance) {
      configCache[configIndex] = {
        options: storeOptions,
        store: redisStore.createStore(opts)
      };
      instance = configCache[configIndex].store;
      instance.client.on('connect', function() {
        return resolve(instance);
      });
      instance.client.on('error', function(err) {
        return reject(err);
      });
      instance.client.on('end', function() {
        return reject(instance);
      });
    }
  });
};


exports.cleanCache = function cleanCache() {
  configCache = {};
};

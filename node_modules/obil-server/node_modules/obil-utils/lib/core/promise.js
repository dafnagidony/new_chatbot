/**
 * @function promise
 * @desc Wraps native Promises
 * @param {function} executor
 * @returns {object} promise
 */
exports.promise = function promise(executor) {
  return new Promise(executor);
};

/**
 * @function promise.[all|race|resolve|reject]
 * @desc Maps `Promise` methods
 * @returns {object} promise
 */
['all', 'race', 'resolve', 'reject'].map(function(method) {
  return (exports.promise[method] = (global.Promise || {})[method]);
});

/**
 * @function defer
 * @desc Constructs a {promise, resolve, reject} object
 * @returns {object} {promise, resolve, reject}
 */
exports.defer = function defer() {
  var resolve;
  var reject;

  var promise = exports.promise(function promise() {
    resolve = arguments[0];
    reject = arguments[1];
  });

  return {
    resolve: resolve,
    reject: reject,
    promise: promise
  };
};

/**
 * @function delay
 * @desc Delays Promise Chain until x ms
 * @param {number} ms
 * @returns {object} promise
 */
exports.delay = function delay(ms) {
  var resolver = exports.defer();
  var now = Date.now();

  setTimeout(function() {
    resolver.resolve(Date.now() - now);
  }, ms);

  return resolver.promise;
};

/**
 * @function settle
 * @desc Settles all the values in the array - `rejected or resolved`.
 * @param {array} iterable
 * @returns {object} promise
 */
exports.settle = function settle(iterable) {
  var resolver = Promise.resolve();
  var values = [];

  iterable.forEach(function(promise, index) {
    // @note To avoid `Uncaught` error messages.
    promise.catch(function() {});

    resolver = resolver
      .then(function() {
        return promise;
      })
      .then(function(value) {
        return {
          status: 'resolved',
          value: value
        };
      })
      .catch(function(reason) {
        return {
          status: 'rejected',
          value: reason
        };
      })
      .then(function(value) {
        values[index] = value;

        return values;
      });
  });

  return resolver;
};

/**
 * @function done
 * @desc Ends the promise chain.
 * @param {object} promise
 * @param {function} onFulfilled
 * @param {function} onRejected
 * @returns {void}
 */
exports.done = function done(promise, onFulfilled, onRejected) {
  promise.then(onFulfilled, onRejected);
};

var test = require('tape');
var core = require('../..').core;

test('promise', {skip: false}, function(t) {
  t.test('promise.[all|race|resolve|reject]', function(tt) {
    tt.test('should expose Promise methods', function(ttt) {
      var promise = core.promise;

      ttt.equal(promise(function() {}).constructor, Promise, 'reference the Promise function');
      ttt.equal(typeof promise.all, 'function', 'and reference the static Promise function, all');
      ttt.equal(typeof promise.race, 'function', 'and reference the static Promise function, race');
      ttt.equal(typeof promise.resolve, 'function', 'and reference the static Promise function, resolve');
      ttt.equal(typeof promise.reject, 'function', 'and reference the static Promise function, reject');
      ttt.end();
    });
  });

  t.test('defer', function(tt) {
    tt.test('should construct a {promise, resolve, reject} object', function(ttt) {
      var defer = core.defer();

      ttt.equal(typeof defer.resolve, 'function', 'reference executor\'s resolve method');
      ttt.equal(typeof defer.reject, 'function', 'and reference executor\'s reject method');
      ttt.equal(defer.promise.constructor, Promise, 'and reference the Promise function');
      ttt.end();
    });
  });

  t.test('delay', function(tt) {
    tt.test('should delay the Promise Chain until x ms', function(ttt) {
      var delay = core.delay(1000);

      ttt.plan(2);
      ttt.equal(delay.constructor, Promise, 'reference the Promise function');
      delay.then(function(value) {
        ttt.ok(value >= 1000, 'and ensure that it takes x ms (if not slightly over, given the run loop\'s timing)');
      });
    });
  });

  t.test('settle', function(tt) {
    tt.test('should settle all the values in the array - `rejected or resolved`', function(ttt) {
      ttt.plan(4);

      function asyncA() {
        var defer = core.defer();

        setTimeout(function() {
          ttt.pass();
          defer.resolve('asyncA');
        }, 1000);

        return defer.promise;
      }

      function asyncB() {
        var defer = core.defer();

        setTimeout(function() {
          ttt.pass();
          defer.reject('asyncB');
        }, 500);

        return defer.promise;
      }

      function asyncC() {
        var defer = core.defer();

        setTimeout(function() {
          ttt.pass();
          defer.resolve('asyncC');
        }, 1);

        return defer.promise;
      }

      function message(value, status) {
        return {
          status: status,
          value: value
        };
      }

      core.settle([asyncA(), asyncB(), asyncC()])
        .then(function(values) {
          var expected = [
            message('asyncA', 'resolved'),
            message('asyncB', 'rejected'),
            message('asyncC', 'resolved')
          ];

          ttt.deepEqual(values, expected, 'settles values in the array, preserving the order');
        });
    });
  });

  t.test('done', function(tt) {
    tt.test('Ends the promise chain in a resolved state', function(ttt) {
      ttt.plan(2);

      function asyncA() {
        var defer = core.defer();

        setTimeout(function() {
          ttt.pass();
          defer.resolve('asyncA');
        }, 1000);

        return defer.promise;
      }

      core.done(asyncA(), function(value) {
        ttt.equal(value, 'asyncA', 'gets the `value`');
      });
    });

    tt.test('Throws a `TypeError` if chained', function(ttt) {
      ttt.plan(2);

      function asyncA() {
        var defer = core.defer();

        setTimeout(function() {
          ttt.pass();
          defer.resolve('asyncA');
        }, 1000);

        return defer.promise;
      }

      try {
        core.done(asyncA(), function() {
        }).then(function() {});
      } catch (err) {
        ttt.equal(typeof err, 'object', 'Cannot read property `then` of undefined');
      }
    });

    tt.test('Ends the promise in a rejected state', function(ttt) {
      ttt.plan(2);

      function asyncA() {
        var defer = core.defer();

        setTimeout(function() {
          ttt.pass();
          defer.reject('asyncA');
        }, 1000);

        return defer.promise;
      }

      core.done(asyncA(), function() {
      }, function(reason) {
        ttt.equal(reason, 'asyncA', 'gets the `reason`');
      });
    });
  });
});
